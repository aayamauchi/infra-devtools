#!/bin/bash
# chkconfig:   2345 98 2
# description: generic initscript wrapper
# processname: processname
#
### BEGIN INIT INFO
# Provides:
# Required-Start: $local_fs $network
# Required-Stop: $local_fs $network
# Should-Start:
# Should-Stop:
# Default-Start: 2 3 4 5
# Default-Stop: 0 1 6
# Short-Description:
# Description:
### END INIT INFO

source /etc/init.d/functions
source /lib/lsb/init-functions

# Everything here really should be in a lib, but no way to
# impleement it and have it available on a system.

# Generic extensions of the initscript functions.
# ===

process_status() {

    # A status function which allows for silent operation as well
    # as allowing inverting return codes 0 and 3 to make life
    # easier when stopping a process, where 0 is the desired state.

    local ret_val=0

    while [[ ${1} =~ ^(-q|--quiet|-i|--invert) ]] ; do
        case ${1} in
        -q|--quiet)
            local quiet=true
        ;;
        -i|--invert)
            local invert=true
        ;;
        esac
        shift
    done

    msg="$( status ${@} )" || ret_val=${?}

    if [ -z "${quiet+set}" ] ; then
        if [ ${ret_val} -eq 0 ] ; then
            log_success_msg "${msg}"
        else
            log_failure_msg "${msg}"
        fi
    fi

    if [ -n "${invert+set}" ] ; then
        ret_val=$( echo ${ret_val} | tr 03 30 )
    fi

    return ${ret_val}
}

process_stop() {

    # A stop function with stale pid and lock file autoclearing,
    # retries, and a sigkill if everything else fails.

    local process_state=0
    local retry_limit=${RETRY_LIMIT-3} retries=0

    local args=(${@})
    local pid_file= lock_file= process_name=

    while [ ${#} -gt 0 ] ; do
        if [ ${#} -eq 1 ] ; then
            process_name=${1}
            shift
            break
        fi
        case ${1} in
        -p)
            shift
            pid_file=${1}
        ;;
        -l)
            shift
            lock_file=${1}
        ;;
        esac
        shift
    done
    process_status -q -i ${args[@]} || process_state=${?}
 
    while [ ${retries} -lt ${retry_limit} ] ; do

        # Remove stale pid or lock files.
        if [ ${process_state} -gt 0 ] ; then
            if [ ${process_state} -le 2 ] ; then
                rm -f ${pid_file} ${lock_file}
            else
                stop ${@}
            fi
            process_status -q -i ${@} || process_state=${?}
        fi

        if [ ${process_state} -eq 4 ] ; then
            # There is no resean to continue if this is permissions problem.
            log_failure_msg insufficient privilege to stop process
            return 4
        fi

        [ ${process_state} -ne 0 ] || break

        ((retries++))
    done

    if [ ${process_state} -eq 0 ] ; then
        log_success_msg
    else
        # Fuck.  If the pid file is there, need to use it.
        log_failure_msg "max retries (${retry_limit}) exceeeded, performing sigkill"
        if [ -n "${pid_file}" ] ; then
            kill -9 $(< ${pid_file} )
        else
            killall -9 -u ${PROG_USER}
        fi

        process_status -q -i ${@} || process_state=${?}

        if [[ ${process_state} =~ ^[12]$ ]] ; then
            rm -f ${pid_file} ${lock_file}
            process_status -q -i ${@} || process_state=${?}
        fi

        if [ ${process_state} -eq 0 ] ; then
            log_success_msg "process sigkill succeeed"
        else
            log_failure_msg "process sigkill failed"
        fi
    fi

    return ${process_state}
}

process_start() {

    # Generic function to start a process using the initscript daemon function.

    local args=("${@}")
    local process_name= pid_file= lock_file=

    while [ ${#} -gt 0 ] ; do
        if [ ${#} -eq 1 ] ; then
            process_name=${1}
            shift
            break
        fi
        case "${1}" in
        -p)
            shift
            pid_file=${1}
        ;;
        -l)
            shift
            lock_file=${1}
        ;;
        esac
    done
        
    # TODO -- make this part of the daemon function return.
    if [ ${UID} -ne 0 ] ; then
        log_failure_msg superuser privileges are required
        return 4
    fi

    local current_state=0
    # Subclass this?
    process_status -q ${args[@]} || process_state=${?}

    case "${process_state}" in
        0)
            log_success_msg "${PROG} is already running"
            return 0
        ;;
        [12])
            # Try clearing pid and lock files and hope for the best.
            rm -f ${PID_FILE} ${LOCK_FILE}
        ;;
    esac

    ulimit ${ULIMIT_OPTS} &>/dev/null || true

    # TODO: check this earlier and throw an error if required envs are not set.
    local cmd=${PROG_CMD}
##    local cmd="PM2_HOME=${PM2_HOME} USER=${PROG_USER} ${PM2_CMD} start"
##    cmd+=" ${APPLICATION_DIRECTORY}/${APPLICATION_START}"
##    cmd+=" --output ${PM2_OUT_LOG}"
##    cmd+=" --error ${PM2_ERR_LOG}"
##    cmd+=" --pid ${PID_FILE}"
##    cmd+=" --interpreter=${APPLICATION_DIRECTORY}/node/bin/node"

##    # This may not be needed, or may actually cause a problem.
##    cd ${APPLICATION_DIRECTORY}

    local retries= retry_limit=${RETRY_LIMIT-1}

    # Fuck.  The env args.
    for ((retries=0;retries<retry_limit;retries++)) ; do
        daemon ${START_STOP_DAEMON_ARGS} \
            "${cmd} 1>>${DAEMON_LOG_FILE} 2>>${DAEMON_LOG_FILE}" 

        sleep ${STOP_RETRY_INTERVAL-3}

        if process_status -q ${args[@]} ; then
            touch ${lock_file}
            log_success_msg
            return 0
        else
            rm -f ${pid_file}
        fi
    done

    log_failure_msg unable to start ${process_name} after ${retry_limit} tries
    return 1
}

prog_defined() {
    printf -- '%s\n' "${PROG_COMMANDS[@]}" | grep -q "${1}"
}

prog_usage() {
    printf -- 'Usage: %s <' ${PROG}
    printf -- '%s|' ${PROG_COMMANDS[@]} | sed -e 's/|$/>/'
    echo
}

: ${PROG:=${0##*/}}

# These have to be overridable.
# TODO: do we really want to do this?
prog_status() {
    # Status check for the app managed by pm2.

    local ret_val=0
    local msg=
    pm2_status ${1} && app_status ${1} || ret_val=${?}

    if [[ ! ${1} =~ ^(-q|--quiet)$ ]] ; then
        if [ ${ret_val} -eq 0 -a ${UID} -eq 0 ] ; then
            # Do not let non-root status checks return 4.
            # Also, running the list command when pm2 is
            # not running will actually silently start the
            # daemon, which is highly undesirable.
            app_list
        fi
    fi
    
    return ${ret_val}
}

prog_stop() {
    # Get the args right -- set the generic process_stop as the default.
    process_stop
}

if [ -r /etc/sysconfig/${PROG} ] ; then
    source /etc/sysconfig/${PROG}
fi

# Standard variables which must be set for this script to work
# ===
: ${PROG_USER:=${PROG}}
: ${PROG_GROUP:=${PROG_USER}}
: ${PROG_HOME:=$( getent passwd ${PROG_USER} | cut -d: -f6 )}

if ! { declare -p PROG_COMMANDS 2>/dev/null | grep -qe '^declare -a' ; } ; then
    if [ -n "${PROG_COMMANDS+set}" ] ; then
        PROG_COMMANDS=( ${PROG_COMMANDS} )
    else
        ${PROG_COMMANDS=($( declare -F | sed -sne '/[[:space:]]prog_/ {s/.*prog_/a;p}' | sort ))}
    fi
fi

# TODO: yikes.  More shit to standardize/convert.

# This is for the daemon command -- not pm2 or the application
: ${LOG_PATH:=/var/log/${PROG}}

: ${STOP_RETRY_INTERVAL:=3}
# By default, the max number of stop retry attempts is unlimited.
[[ ${STOP_RETRY_MAX} =~ ^[[:digit:]] ]] || unset STOP_RETRY_MAX

: ${PID_FILE_PATH:=${PM2_HOME}/pids}
: ${PID_FILE_NAME:=${PROG}}
: ${PID_FILE:=${PID_FILE_PATH}/${PID_FILE_NAME}}
: ${LOCK_FILE:=/var/lock/subsys/${PROG}}

START_STOP_DAEMON_ARGS+="${START_STOP_DAEMON_ARGS+ }--user ${PROG_USER} --pidfile ${PID_FILE} --check ${PROG}"

# This is what is currently set as the default.
: ${ULIMIT_OPTS:='-n 64000 -u 64000'}


exit_val=0
case "${1}" in
    start)
        echo -n $"Starting ${PROG}: "
        if printf -- '%s\n' "${PROG_COMMANDS[@]}" | grep -q start ; then
            prog_start || exit_val=${?}
        else
            log_failure_msg "unimplemented function 'prog_start'"
            exit_val=3
        fi
    ;;
    stop)
        echo -n $"Stopping ${PROG}: "
        if function_defined prog_stop ; then
            prog_stop || exit_val=${?}
        else
            log_failure_msg "unimplemented function 'prog_stop'"
            exit_val=3
        fi
    ;;
    restart)
        # Not ideal, but if a separate restart function exists, use it.
        if function_defined prog_restart ; then
            echo -n $"Restarting ${PROG}"
            prog_restart || exit_val=${?}
        else
            echo -n $"Stopping ${PROG}: "
            if function_defined prog_stop ; then
                prog_stop || exit_val=${?}
            else
                log_failure_msg "unimplemented function 'prog_stop'"
                exit_val=3
            fi
            if [ ${exit_val} -eq 0 ] ; then
                echo -n $"Starting ${PROG}: "
                if function_defined prog_start ; then
                    prog_start || exit_val=${?}
                else
                    log_failure_msg "unimplemented function 'prog_start'"
                    exit_val=3
                fi
            fi
        fi
    ;;
    reload|force-reload)
        echo -n $"Reloading ${PROG}"
        if function_defined prog_reload ; then
            prog_reload || exit_val=${?}
        else
            log_failure_msg "unimplemented function 'prog_reload'"
            exit_val=3
        fi
        ;;
    status)
        if function_defined prog_status ; then
            prog_status || exit_val=${?}
        else
            log_failure_msg "unimplemented function 'prog_status'"
            exit_val=4
        fi
        ;;
    try-restart|condrestart)
        if function_defined prog_status ; then
            if prog_status -q ; then
                if function_defined prog_restart ; then
                    echo -n $"Restarting ${PROG}"
                    prog_restart || exit_val=${?}
                else
                    echo -n $"Stopping ${PROG}: "
                    if function_defined prog_stop ; then
                        prog_stop || exit_val=${?}
                    else
                        log_failure_msg "unimplemented function 'prog_stop'"
                        exit_val=3
                    fi
                    if [ ${exit_val} -eq 0 ] ; then
                        echo -n $"Starting ${PROG}: "
                        if function_defined prog_start ; then
                            prog_start || exit_val=${?}
                        else
                            log_failure_msg "unimplemented function 'prog_start'"
                            exit_val=3
                        fi
                    fi
                fi
            else
                log_success_msg "${PROG} not not running"
            fi
        else
           log_failure_msg "unimplemented function 'prog_status'"
        fi
    ;;
    reload|force-reload)
        # Nodejs pm2 actually implements a reloca.
        echo -n $"Reloading ${PROG}"
        if function_defined prog_reload ; then
            prog_reload || exit_val=${?}
        else
            log_failure_msg "unimplemented function 'prog_reload'"
            exit_val=3
        fi
        ;;
    *)
        # ???
        prog_usage
        #echo $"$( usage )"
        exit_val=2
        ;;
esac

exit ${exit_val}
