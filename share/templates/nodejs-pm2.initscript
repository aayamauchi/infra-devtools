#!/bin/bash
# chkconfig:   2345 98 02
# description: generic initscript wrapper
# processname: processname

### BEGIN INIT INFO
# Provides:
# Required-Start: $local_fs $network
# Required-Stop: $local_fs $network
# Should-Start:
# Should-Stop:
# Default-Start: 2 3 4 5
# Default-Stop: 0 1 6
# Short-Description:
# Description:
### END INIT INFO

source /etc/init.d/functions
source /lib/lsb/init-functions

: ${PROG:=${0##*/}}

if [ -r /etc/sysconfig/${PROG} ] ; then
    source /etc/sysconfig/${PROG}
fi

# This script is particularly messy due to the fact tht it's
# really managing two different processes.  Breaking a pm2
# script out separately really would have been a good idea.

# application environment variables
# ===
: ${PROG_USER:=${PROG}}
: ${PROG_GROUP:=${PROG_USER}}
: ${PROG_HOME:=$( getent passwd ${PROG_USER} | cut -d: -f6 )}

# Even though these are used by pm2, it's merely to describe
# this application. If pm2 were broken out separatetly, these
# would be parameters passwd to pm2 to specify which app is
# the command applies to.
: ${APPLICATION_DIRECTORY:=${PROG_HOME}}
: ${APPLICATION_START:=index.js}

# pm2 enviroment variables
# ===

# PM2_HOME is actually used by pm2.  The rest are helpers
# used by this script.
: ${PM2_HOME:=/var/run/${PROG}/.pm2}
: ${PM2_CMD:="$( which --skip-alias pm2 )"}
: ${PM2_PID_FILE:=${PM2_HOME}/pm2.pid}

# TODO -- fully debug this, or remove it.
# What was I doing here?
# Generally do not want the pm2 process console outputs.
if [ -d "${PM2_LOG_PATH}" ] ; then
    PM2_OUT_LOG=${PM2_LOG_PATH}/pm2-${PROG}.out
    PM2_ERR_LOG=${PM2_LOG_PATH}/pm2-${PROG}.err
else
    PM2_OUT_LOG=/dev/null
    PM2_ERR_LOG=/dev/null
fi

# This is for the daemon command -- not pm2 or the application
: ${LOG_PATH:=/var/log/${PROG}}

: ${STOP_RETRY_INTERVAL:=3}
# By default, the max number of stop retry attempts is unlimited.
[[ ${STOP_RETRY_MAX} =~ ^[[:digit:]] ]] || unset STOP_RETRY_MAX

: ${PID_FILE_PATH:=${PM2_HOME}/pids}
: ${PID_FILE_NAME:=${PROG}}
: ${PID_FILE:=${PID_FILE_PATH}/${PID_FILE_NAME}}
: ${LOCK_FILE:=/var/lock/subsys/${PROG}}

START_STOP_DAEMON_ARGS+="${START_STOP_DAEMON_ARGS+ }--user ${PROG_USER} --pidfile ${PID_FILE} --check ${PROG}"

# This is what is currently set as the default.
: ${ULIMIT_OPTS:=='-n 64000 -u 64000'}

# Utility functions
# ====

# ===
# Generic extensions of the initscript functions.
# ===

process_status() {

    # A status function which allows for silent operation as well
    # as allowing inverting return codes 0 and 3 to make life
    # easier when stopping a process, where 0 is the desired state.

    local ret_val=0

    while [[ ${1} =~ ^(-q|--quiet|-i|--invert) ]] ; do
        case ${1} in
        -q|--quiet)
            local quiet=true
        ;;
        -i|--invert)
            local invert=true
        ;;
        esac
        shift
    done

    msg="$( status ${@} )" || ret_val=${?}

    if [ -z "${quiet+set}" ] ; then
        if [ ${ret_val} -eq 0 ] ; then
            log_success_msg "${msg}"
        else
            log_failure_msg "${msg}"
        fi
    fi

    if [ -n "${invert+set}" ] ; then
        ret_val=$( echo ${ret_val} | tr 03 30 )
    fi

    return ${ret_val}
}

process_stop() {

    # A stop function with stale pid and lock file autoclearing,
    # retries, and a sigkill if everything else fails.

    local process_state=0
    local retry_limit=${RETRY_LIMIT-3} retries=0

    local args=(${@})
    local pid_file= lock_file= process_name=

    while [ ${#} -gt 0 ] ; do
        if [ ${#} -eq 1 ] ; then
            process_name=${1}
            shift
            break
        fi
        case ${1} in
        -p)
            shift
            pid_file=${1}
        ;;
        -l)
            shift
            lock_file=${1}
        ;;
        esac
        shift
    done
    process_status -q -i ${args[@]} || process_state=${?}
 
    while [ ${retries} -lt ${retry_limit} ] ; do

        # Remove stale pid or lock files.
        if [ ${process_state} -gt 0 ] ; then
            if [ ${process_state} -le 2 ] ; then
                rm -f ${pid_file} ${lock_file}
            else
                stop ${@}
            fi
            process_status -q -i ${@} || process_state=${?}
        fi

        if [ ${process_state} -eq 4 ] ; then
            # There is no resean to continue if this is permissions problem.
            log_failure_msg insufficient privilege to stop process
            return 4
        fi

        [ ${process_state} -ne 0 ] || break

        ((retries++))
    done

    if [ ${process_state} -eq 0 ] ; then
        log_success_msg
    else
        # Fuck.  If the pid file is there, need to use it.
        log_failure_msg "max retries (${retry_limit}) exceeeded, performing sigkill"
        if [ -n "${pid_file}" ] ; then
            kill -9 $(< ${pid_file} )
        else
            killall -9 -u ${PROG_USER}
        fi

        process_status -q -i ${@} || process_state=${?}

        if [[ ${process_state} =~ ^[12]$ ]] ; then
            rm -f ${pid_file} ${lock_file}
            process_status -q -i ${@} || process_state=${?}
        fi

        if [ ${process_state} -eq 0 ] ; then
            log_success_msg "process sigkill succeeed"
        else
            log_failure_msg "process sigkill failed"
        fi
    fi

    return ${process_state}
}

process_start() {

    # Generic function to start a process using the initscript daemon function.

    local args=("${@}")
    local process_name= pid_file= lock_file=

    while [ ${#} -gt 0 ] ; do
        if [ ${#} -eq 1 ] ; then
            process_name=${1}
            shift
            break
        fi
        case "${1}" in
        -p)
            shift
            pid_file=${1}
        ;;
        -l)
            shift
            lock_file=${1}
        ;;
        esac
    done
        
    # TODO -- make this part of the daemon function return.
    if [ ${UID} -ne 0 ] ; then
        log_failure_msg superuser privileges are required
        return 4
    fi

    local current_state=0
    # Subclass this?
    process_status -q ${args[@]} || process_state=${?}

    case "${process_state}" in
        0)
            log_success_msg "${PROG} is already running"
            return 0
        ;;
        [12])
            # Try clearing pid and lock files and hope for the best.
            rm -f ${PID_FILE} ${LOCK_FILE}
        ;;
    esac

    ulimit ${ULIMIT_OPTS} &>/dev/null || true

    # TODO: check this earlier and throw an error if required envs are not set.
    local cmd=${PROG_CMD}
##    local cmd="PM2_HOME=${PM2_HOME} USER=${PROG_USER} ${PM2_CMD} start"
##    cmd+=" ${APPLICATION_DIRECTORY}/${APPLICATION_START}"
##    cmd+=" --output ${PM2_OUT_LOG}"
##    cmd+=" --error ${PM2_ERR_LOG}"
##    cmd+=" --pid ${PID_FILE}"
##    cmd+=" --interpreter=${APPLICATION_DIRECTORY}/node/bin/node"

##    # This may not be needed, or may actually cause a problem.
##    cd ${APPLICATION_DIRECTORY}

    local retries= retry_limit=${RETRY_LIMIT-1}

    # Fuck.  The env args.
    for ((retries=0;retries<retry_limit;retries++)) ; do
        daemon ${START_STOP_DAEMON_ARGS} \
            "${cmd} 1>>${DAEMON_LOG_FILE} 2>>${DAEMON_LOG_FILE}" 

        sleep ${STOP_RETRY_INTERVAL-3}

        if process_status -q ${args[@]} ; then
            touch ${lock_file}
            log_success_msg
            return 0
        else
            rm -f ${pid_file}
        fi
    done

    log_failure_msg unable to start ${process_name} after ${retry_limit} tries
    return 1
}

# Node.js pm2 specific functions
# ===

pm2() {
    runuser \
        -s /bin/bash ${PROG_USER} \
        -c "PM2_HOME=${PM2_HOME} ${PM2_CMD} ${*}"
}

pm2_status() {
    process_status ${@} -p ${PM2_PID_FILE} pm2
}

pm2_nuke() {
    # Doing a stop may not be enough if a different user (ie. root)
    # has invoked just about any pm2 command using the same PM2_HOME.
    # Non-managed process could be using the same content and, worse,
    # the content may no longer be writable by the process user.  The
    # pid files woud have overwritten each other if this has happened.
    # so there is no help coming tracking them down from that source.

    kill -9 $( ps auwwx | grep -e "PM2.*(${PM2_HOME})" )

    local socks=( $(find ${PM2_HOME}/.pm2 -name '*.sock' ) )

    if [ ${#socks[@]} -gt 0 ] ; then
        fuser -k ${socks[@]}
        rm -f ${socks[@]}
    fi
   
    # Assume we are no in a PM2-free world.
    find ${PM2_HOME} \
        \( -user ${PROG_USER} -group ${PROG_GROUP} \) \
        -o -exec chown ${PROG_USER}:${PROG_GROUP} {} \;

}

pm2_stop() {
    local retries=0 pm2_state=0
    
    if [ ${UID} -ne 0 ] ; then
        log_failure_msg superuser privileges are required
        return 4
    fi

    pm2_status -q -i || pm2_state=${?}

    # This "stop all" is what actually kills the "God Daemon",
    # I think.  Really don't care about the exit codes and doubt
    # that they would be usable, any way;

    while [ ${pm2_state} -gt 2 -a ${retries} -lt ${retry_limit} ] ; do

        pm2 stop all || true
        pm2 kill || true
        
        # Sleep time here may be needed.
        sleep 3

        pm2_status -q -i || pm2_state=${?}
    done

    if [ ${pm2_state} -ne 0 ] ; then
        process_stop ${@} || pm2_state=${?}
    fi

    # There is a _nasty_ cornercase to deal when another user
    # (ie. root) starts another daemon process using the same
    # PM2_HOME.  It's _really_ easy to do, and a complete shit
    # show getting things back into a state where it's usable
    # by the process user again.  Hack in a check/fix, no matter
    # the state reported by status check (since it won't know
    # about all the pids which may be running out of PM2_HOME.
    pm2_nuke

    process_status ${@} || pm2_state=${?}

    if [ ${pm2_state} -eq 0 ] ; then
        log_success_msg
    fi

    return ${pm2_state}
}

# Node.js functions for apps managed by pm2.
# ===

app_status() {
    process_status ${@} -p ${PID_FILE} ${PROG}
}

app_list() {
    local ret_val=0

    # Do not do anything if pm2 is not actually running, since
    # this will cause pm2 to silently start a daemon.
    if ! pm2_status -q ; then
        return 1
    fi

    if [ "${UID}" -ne 0 ] ; then
        # Do not perform any pm2 commands without a wrapper --
        # which will require root access to use runuser.  Just
        # about any pm2 command run when the daemon is not
        # actually running will cause pm2 to silentely start
        # one using whatever the current effective ownership.

        return 4
    fi

    pm2 list
}

app_stop() {

    local app_state=0 retries=0 retry_limit=${RETRY_LIMIT-3}
    app_status -q -i || app_state=${?}

    while [ ${app_state} -gt 2 -a ${retries} -lt ${retry_limit} ] ; do
         pm2 stop ${PROG} || true
         pm2 delete ${PROG} || true

        app_status -q -i || app_state=${?}
        ((retries++))
    done

    if [ ${app_state} -eq 0 ] ; then
        log_success_msg
    else
        process_stop ${@} || app_state=${?}
    fi

    return ${app_state}
}

app_start() {

    if [ ${UID} -ne 0 ] ; then
        log_failure_msg superuser privileges are required
        return 4
    fi

    local current_state=0
    full_status -q || current_state=${?}
    case "${current_state}" in
        0)
            log_success_msg "${PROG} is already running"
            return 0
        ;;
        [12])
            # Try clearing pid and lock files and hope for the best.
            rm -f ${PID_FILE} ${LOCK_FILE}
        ;;
    esac

    ulimit ${ULIMIT_OPTS} &>/dev/null || true

    local cmd="PM2_HOME=${PM2_HOME} USER=${PROG_USER} ${PM2_CMD} start"
    cmd+=" ${APPLICATION_DIRECTORY}/${APPLICATION_START}"
    cmd+=" --output ${PM2_OUT_LOG}"
    cmd+=" --error ${PM2_ERR_LOG}"
    cmd+=" --pid ${PID_FILE}"
    cmd+=" --interpreter=${APPLICATION_DIRECTORY}/node/bin/node"

    # This may not be needed, or may actually cause a problem.
    cd ${APPLICATION_DIRECTORY}

    daemon ${START_STOP_DAEMON_ARGS} \
        "${cmd} 1>>${LOG_PATH}/daemon.out 2>>${LOG_PATH}/daemon.err"

    sleep ${STOP_RETRY_INTERVAL}

    # REALLY stupid.  If we don't query pm2 using the app user and
    # someone uses a root sudo, the sockets will end up being owned
    # by a different user.
    if app_status -q ; then
        touch ${LOCK_FILE}
        log_success_msg
        return 0
    else
        rm -f ${PID_FILE}
        log_failure_msg unable to start ${PROG}
        return 1
    fi
}

# TODO: do we really want to do this?
prog_status() {
    # Status check for the app managed by pm2.

    local ret_val=0
    local msg=
    pm2_status ${1} && app_status ${1} || ret_val=${?}

    if [[ ! ${1} =~ ^(-q|--quiet)$ ]] ; then
        if [ ${ret_val} -eq 0 -a ${UID} -eq 0 ] ; then
            # Do not let non-root status checks return 4.
            # Also, running the list command when pm2 is
            # not running will actually silently start the
            # daemon, which is highly undesirable.
            app_list
        fi
    fi
    
    return ${ret_val}
}

prog_stop() {
    app_stop && pm2_stop
}

reload() {

    if [ ${UID} -ne 0 ] ; then
        log_failure_msg superuser privileges are required
        return 4
    fi

    local ret_val=0
    local msg="$( pm2 reload all 2>&1 )" \
        || ret_val=${?}

    if [ ${ret_val} -eq 0 ] ; then
        log_success_msg
    else
        log_failure_msg failed to reload
        echo "${msg}"
        ret_val=1
    fi

    return ${ret_val}
}

commands=($( declare -F | sed -sne '/[[:space:]]prog_/ {s/.*prog_/a;p}' | sort ))

function_defined() {
    printf -- '%s\n' "${commands[@]}" | grep -q ${1}
}

usage() {
    printf -- 'Usage: %s <' ${PROG}
    printf -- '%s|' ${commands[@]} | sed -e 's/|$/>/'
    echo
}

exit_val=0
case "${1}" in
    start)
        echo -n $"Starting ${PROG}: "
        if printf -- '%s\n' "${commands[@]}" | grep -q start ; then
            prog_start || exit_val=${?}
        else
            log_failure_msg "unimplemented function 'prog_start'"
            exit_val=3
        fi
    ;;
    stop)
        echo -n $"Stopping ${PROG}: "
        if function_defined prog_stop ; then
            prog_stop || exit_val=${?}
        else
            log_failure_msg "unimplemented function 'prog_stop'"
            exit_val=3
        fi
    ;;
    restart)
        # Not ideal, but if a separate restart function exists, use it.
        if function_defined prog_restart ; then
            echo -n $"Restarting ${PROG}"
            prog_restart || exit_val=${?}
        else
            echo -n $"Stopping ${PROG}: "
            if function_defined prog_stop ; then
                prog_stop || exit_val=${?}
            else
                log_failure_msg "unimplemented function 'prog_stop'"
                exit_val=3
            fi
            if [ ${exit_val} -eq 0 ] ; then
                echo -n $"Starting ${PROG}: "
                if function_defined prog_start ; then
                    prog_start || exit_val=${?}
                else
                    log_failure_msg "unimplemented function 'prog_start'"
                    exit_val=3
                fi
            fi
        fi
    ;;
    reload|force-reload)
        echo -n $"Reloading ${PROG}"
        if function_defined prog_reload ; then
            prog_reload || exit_val=${?}
        else
            log_failure_msg "unimplemented function 'prog_reload'"
            exit_val=3
        fi
        ;;
    status)
        if function_defined prog_status ; then
            prog_status || exit_val=${?}
        else
            log_failure_msg "unimplemented function 'prog_status'"
            exit_val=4
        fi
        ;;
    try-restart|condrestart)
        if function_defined prog_status ; then
            if prog_status -q ; then
                if function_defined prog_restart ; then
                    echo -n $"Restarting ${PROG}"
                    prog_restart || exit_val=${?}
                else
                    echo -n $"Stopping ${PROG}: "
                    if function_defined prog_stop ; then
                        prog_stop || exit_val=${?}
                    else
                        log_failure_msg "unimplemented function 'prog_stop'"
                        exit_val=3
                    fi
                    if [ ${exit_val} -eq 0 ] ; then
                        echo -n $"Starting ${PROG}: "
                        if function_defined prog_start ; then
                            prog_start || exit_val=${?}
                        else
                            log_failure_msg "unimplemented function 'prog_start'"
                            exit_val=3
                        fi
                    fi
                fi
            else
                log_success_msg "${PROG} not not running"
            fi
        else
           log_failure_msg "unimplemented function 'prog_status'"
        fi
    ;;
    reload|force-reload)
        # Nodejs pm2 actually implements a reloca.
        echo -n $"Reloading ${PROG}"
        if function_defined prog_reload ; then
            prog_reload || exit_val=${?}
        else
            log_failure_msg "unimplemented function 'prog_reload'"
            exit_val=3
        fi
        ;;
    *)
        # ???
        usage
        #echo $"$( usage )"
        exit_val=2
        ;;
esac

exit ${exit_val}
