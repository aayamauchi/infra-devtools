# We'll have to define PROG shit here.

# These are passed to pm2, but they are for managing a specific app.
: ${APPLICATION_DIRECTORY:=${PROG_HOME}}
: ${APPLICATION_START:=index.js}

# pm2 enviroment variables
# ===

# PM2_HOME is actually used by pm2.  This is the controllwing daemon
# "home", not the application "home".
: ${PM2_HOME:=/var/run/${PROG_NAME}/.pm2}
: ${PM2_CMD:="$( which --skip-alias pm2 )"}
: ${PM2_PID_FILE:=${PM2_HOME}/pm2.pid}

# Node.js pm2 specific functions
# ===

pm2() {
    runuser \
        -s /bin/bash ${PROG_USER} \
        -c "cd ${PM2_HOME} ; PM2_HOME=${PM2_HOME} ${PM2_CMD} ${*}"
}

pm2_status() {
    process_status ${@} -p ${PM2_PID_FILE} pm2
}

pm2_nuke() {
    # Doing a stop may not be enough if a different user (ie. root)
    # has invoked just about any pm2 command using the same PM2_HOME.
    # This is required to ensure that processes started outside of
    # this script with the same PM2_HOME are actually killed.

    local socks=( $( find ${PM2_HOME} -name '*.sock' ) )

    if [ ${#socks[@]} -gt 0 ] ; then
        # TODO: loop this?  At least capture on error and bullet-proof.
        fuser -k ${socks[@]}
        rm -f ${socks[@]}
    fi
   
    # Assume we are no in a PM2-free world.  Make sure anything which
    # may have been chowned in PM2_HOME is owned by the process user.
    find ${PM2_HOME} \
        ! \( -user ${PROG_USER} -group ${PROG_GROUP} \) \
        -exec chown ${PROG_USER}:${PROG_GROUP} {} \;

    # TODO; bullet-proof and make a sensible return code
}

pm2_stop() {
    local retries=0 pm2_state=0 retry_limit=${RETRY_LIMIT=3}
    
    if ! assert_privileges ; then
        log_failure_msg insufficient privileges
        return 4
    fi

    pm2_status -q -i || pm2_state=${?}

    sleep ${STOP_RETRY_INTERVAL-3}

    while [ ${pm2_state} -gt 2 -a ${retries} -lt ${retry_limit} ] ; do

        pm2 kill || true
        
        #sleep ${STOP_RETRY_INTERVAL-3}

        # Explicitly protect this from folks who love run error traps.
        pm2_status -q -i && pm2_state=0 || pm2_state=${?}
        ((retries++))
    done

    if [ ${pm2_state} -gt 2 ] ; then
        process_stop -p ${PM2_PID_FILE} pm2 || true
    fi

    pm2_status -q -i && pm2_state=0 || pm2_state=${?}

    if [[ ${pm2_state} -lt 3 ]] ; then
        rm -f ${PM2_PID_FILE}
        pm2_state=0
    fi

    if [ ${pm2_state} -eq 0 ] ; then
        log_success_msg
    fi

    # TODO: we need to do soemthing about the return value here.
    pm2_nuke

    return ${pm2_state}
}

# Node.js functions for apps managed by the pm2 daemon.
# ===

app_status() {
    process_status ${@} -p ${PID_FILE} -l ${LOCK_FILE} ${PROG_NAME}
}

app_state_code() {
    app_status -q ${@} && echo 0 || echo ${?}
}

app_list() {
    local ret_val=0

    # Do not do anything if pm2 is not actually running, since
    # this will cause pm2 to silently start a daemon.
    if pm2_status -q -i ; then
        return 1
    fi

    if ! assert_privileges ; then
        # Do not perform any pm2 commands without a wrapper --
        # which will require root access to use runuser.  Just
        # about any pm2 command run when the daemon is not
        # actually running will cause pm2 to silentely start
        # one using the current effective user.

        return 4
    fi

    pm2 list
}

app_stop() {

    local app_state=0 retries=0 retry_limit=${RETRY_LIMIT-3}
    app_state=$( app_state_code -i )

    while [ ${app_state} -gt 2 -a ${retries} -lt ${retry_limit} ] ; do
        # if this is not explicitly named in the startup, this will be
        # the name of js file used to start the daemon.
        pm2 stop ${PROG_NAME} || true
        pm2 delete ${PROG_NAME} || true

        app_state=$( app_state_code -i )
        ((retries++))
    done

    if [ ${app_state} -lt 3 ] ; then
        rm -f ${PID_FILE} /var/lock/subsys/${LOCK_FILE}
        app_state=0
    fi

    if [ ${app_state} -ne 0 ] ; then
        process_stop -p ${PID_FILE} -l ${LOCK_FILE} || true
        app_state=$( app_state_code -i )
    fi

    if [ ${app_state} -eq 0 ] ; then
        log_success_msg
    else
        log_failure_msg unable to stop application normally
    fi

    return ${app_state}
}

prog_stop() {
    if ! assert_privileges ; then
        log_failure_msg insufficient privileges
        return 4
    fi
    app_stop || true
    pm2_stop
}

prog_reload() {

    if ! assert_privileges ; then
        log_failure_msg insufficient privileges
        return 4
    fi

    local ret_val=0
    local msg="$( pm2 reload ${PROG_NAME} 2>&1 )" \
        || ret_val=${?}

    if [ ${ret_val} -eq 0 ] ; then
        log_success_msg
    else
        log_failure_msg failed to reload
        echo "${msg}"
        ret_val=1
    fi

    return ${ret_val}
}

prog_status() {
    local ret_val=0
    app_status "${@}" || ret_val=${?}

    [[ "${*}" =~ -q ]] || app_list "${@}" || true

    return ${ret_val}
}
    

PID_FILE_NAME=${PROG_NAME}
PID_FILE_PATH=${PM2_HOME}/pids
PID_FILE=${PID_FILE_PATH}/${PID_FILE_NAME}

#        super $PM2 start $APPLICATION_DIRECTORY/$APPLICATION_START --output $LOGFILE --error $LOGFILE --pid $PIDFILE --interpreter=$APPLICATION_DIRECTORY/node/bin/node
# Can't do this using a function.
# WTF?
#PROG_START_COMMAND="PM2_HOME=${PM2_HOME} ${PM2_CMD}"
PROG_START_COMMAND="cd ${APPLICATION_DIRECTORY} ; PM2_HOME=${PM2_HOME} ${PM2_CMD}"
PROG_START_COMMAND+=" start ${APPLICATION_DIRECTORY}/${APPLICATION_START}"
# If we do not do this, the app is named "index".
PROG_START_COMMAND+=" --name ${PROG_NAME}"
PROG_START_COMMAND+=" --output /var/log/bodhi-job-engine/bodhi-job-engine.log"
PROG_START_COMMAND+=" --error /var/log/bodhi-job-engine/bodhi-job-engine.log"
PROG_START_COMMAND+=" --pid ${PID_FILE}"
PROG_START_COMMAND+=" --interpreter=${APPLICATION_DIRECTORY}/node/bin/node"
PROG_START_COMMAND="{ ${PROG_START_COMMAND} ; } &>/dev/null"
